<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>SpaceSim Visualizer</title>
    <style>
        html,
        body,
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(42, 42, 42, 0.8);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-family: sans-serif;
            font-size: 12px;
            z-index: 1000;
        }
        #controls button {
            background: #48b;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
        }
        #controls button:hover {
            background: #5ac;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cesium@1.105.0/Build/Cesium/Widgets/widgets.css" />
</head>

<body>
    <div id="cesiumContainer"></div>
    <div id="controls">
        <div><strong>SpaceSim Controls</strong></div>
        <button onclick="focusOnSatellites()">Focus on Satellites</button>
        <button onclick="resetView()">Reset View</button>
        <button onclick="window.open('dashboard.html', '_blank')">ðŸ“Š Dashboard</button>
        <div id="missionTime">Mission Time: --</div>
        <div id="timeScale">Time Scale: --</div>
        <div id="satelliteCount">Satellites: 0</div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/cesium@1.105.0/Build/Cesium/Cesium.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/satellite.js@5.0.0/dist/satellite.min.js"></script>
    <script>
        // Set Cesium Ion token if provided via server
        fetch('/cesium-token')
            .then(res => res.text())
            .then(token => {
                if (token && token !== 'undefined') {
                    Cesium.Ion.defaultAccessToken = token;
                }
            })
            .catch(e => console.warn('No Cesium token available, using default imagery'));

        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJkMDFiZGM3Mi1iMjEzLTQwMTMtOTEyNS1mMjBiMDljYWFkNGUiLCJpZCI6MzUyMjg4LCJpYXQiOjE3NjA5NzA2MTR9.Gnss-6ftbJn9rivjkDo2xv7qsmXjnipp1EYAh5-ojKs';
        const viewer = new Cesium.Viewer('cesiumContainer', {
            timeline: false,        // Disable timeline - we control time via mission service
            animation: false,       // Disable animation controls
            sceneModePicker: true,
            baseLayerPicker: true,
            homeButton: true,
            fullscreenButton: true,
            vrButton: false
        });
        
        // Set initial camera view to show orbital altitude
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(0.0, 0.0, 15000000) // 15,000 km altitude for orbital view
        });

        const TELEMETRY_ENDPOINT = '/telemetry';
        let missionTimeInfo = null;

        async function fetchTelemetry() {
            try {
                const res = await fetch(TELEMETRY_ENDPOINT);
                const data = await res.json();
                return data;
            } catch (e) {
                console.warn('telemetry fetch failed', e);
                return [];
            }
        }

        // Extract mission time from telemetry data
        function updateMissionTime(telemetry) {
            if (telemetry.length > 0) {
                const sample = telemetry[0];
                if (sample.mission_time) {
                    // Fix malformed timestamp: remove duplicate timezone info
                    let timeString = sample.mission_time;
                    if (timeString.includes('+00:00Z')) {
                        timeString = timeString.replace('+00:00Z', 'Z');
                    }
                    
                    try {
                        const missionDate = new Date(timeString);
                        if (isNaN(missionDate.getTime())) {
                            console.error('Invalid date:', timeString);
                            return;
                        }
                        
                        const timeScale = sample.time_scale || 1.0;
                        document.getElementById('missionTime').textContent = `Mission Time: ${missionDate.toISOString().slice(0, 19)}Z`;
                        document.getElementById('timeScale').textContent = `Time Scale: ${timeScale}x`;
                    } catch (e) {
                        console.error('Error parsing mission time:', timeString, e);
                    }
                }
            }
        }

        const markers = {};
        const orbitalPaths = {};
        const lastSeen = {}; // Track when each satellite was last seen
        const SATELLITE_TIMEOUT_MS = 10000; // 10 seconds timeout

        // Function to generate orbital path using simplified orbital mechanics
        function generateOrbitalPath(orbital_elements, currentPosition) {
            if (!orbital_elements || orbital_elements.alt_km === undefined) {
                return null;
            }

            try {
                const alt_km = orbital_elements.alt_km;
                const inc_deg = orbital_elements.inc_deg || 0;
                const raan_deg = orbital_elements.raan_deg || 0;
                const argp_deg = orbital_elements.argp_deg || 0;
                
                // Convert to radians
                const inc_rad = inc_deg * Math.PI / 180;
                const raan_rad = raan_deg * Math.PI / 180;
                const argp_rad = argp_deg * Math.PI / 180;
                
                // Orbital parameters
                const RE = 6378.137; // Earth radius km
                const a = RE + alt_km; // Semi-major axis
                const mu = 398600.4418; // Earth gravitational parameter km^3/s^2
                const n = Math.sqrt(mu / (a * a * a)); // Mean motion rad/s
                
                const positions = [];
                const num_points = 120; // Points for smooth orbit
                
                // Generate orbital path using parametric orbit equations
                for (let i = 0; i <= num_points; i++) {
                    const theta = (i / num_points) * 2 * Math.PI; // True anomaly
                    
                    // Position in orbital plane
                    const x_orb = a * Math.cos(theta);
                    const y_orb = a * Math.sin(theta);
                    const z_orb = 0.0;
                    
                    // Apply orbital rotations to get ECEF coordinates
                    // Rotate by argument of perigee (around z-axis)
                    const cos_argp = Math.cos(argp_rad);
                    const sin_argp = Math.sin(argp_rad);
                    const x1 = x_orb * cos_argp - y_orb * sin_argp;
                    const y1 = x_orb * sin_argp + y_orb * cos_argp;
                    const z1 = z_orb;
                    
                    // Rotate by inclination (around x-axis)
                    const cos_inc = Math.cos(inc_rad);
                    const sin_inc = Math.sin(inc_rad);
                    const x2 = x1;
                    const y2 = y1 * cos_inc - z1 * sin_inc;
                    const z2 = y1 * sin_inc + z1 * cos_inc;
                    
                    // Rotate by RAAN (around z-axis)
                    const cos_raan = Math.cos(raan_rad);
                    const sin_raan = Math.sin(raan_rad);
                    const x_ecef = x2 * cos_raan - y2 * sin_raan;
                    const y_ecef = x2 * sin_raan + y2 * cos_raan;
                    const z_ecef = z2;
                    
                    // Validate coordinates
                    if (isFinite(x_ecef) && isFinite(y_ecef) && isFinite(z_ecef)) {
                        positions.push(new Cesium.Cartesian3(x_ecef * 1000, y_ecef * 1000, z_ecef * 1000));
                    }
                }
                
                return positions.length > 2 ? positions : null;
            } catch (e) {
                console.warn('Failed to generate orbital path:', e);
                return null;
            }
        }



        // Control functions
        function focusOnSatellites() {
            const satellites = Object.values(markers);
            if (satellites.length > 0) {
                const positions = satellites.map(sat => sat.position._value || sat.position);
                const boundingSphere = Cesium.BoundingSphere.fromPoints(positions);
                viewer.camera.viewBoundingSphere(boundingSphere, new Cesium.HeadingPitchRange(0, -0.5, boundingSphere.radius * 2));
            }
        }
        
        function resetView() {
            viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(0.0, 0.0, 15000000)
            });
        }
        
        // Update satellite count display
        function updateSatelliteCount() {
            document.getElementById('satelliteCount').textContent = `Satellites: ${Object.keys(markers).length}`;
        }

        // Remove satellites that haven't been seen recently
        function removeStaleSatellites() {
            const now = Date.now();
            const staleSatellites = [];
            
            // Debug: log current state
            console.log('Checking for stale satellites. Current time:', now);
            console.log('Last seen times:', lastSeen);
            
            for (const [id, lastSeenTime] of Object.entries(lastSeen)) {
                const timeSinceLastSeen = now - lastSeenTime;
                console.log(`Satellite ${id}: last seen ${timeSinceLastSeen}ms ago (timeout: ${SATELLITE_TIMEOUT_MS}ms)`);
                
                if (timeSinceLastSeen > SATELLITE_TIMEOUT_MS) {
                    staleSatellites.push(id);
                }
            }
            
            staleSatellites.forEach(id => {
                console.log(`Removing stale satellite: ${id}`);
                
                // Remove satellite marker
                if (markers[id]) {
                    viewer.entities.remove(markers[id]);
                    delete markers[id];
                }
                
                // Remove orbital path
                if (orbitalPaths[id]) {
                    viewer.entities.remove(orbitalPaths[id]);
                    delete orbitalPaths[id];
                }
                
                // Remove from last seen tracking
                delete lastSeen[id];
            });
            
            if (staleSatellites.length > 0) {
                console.log(`Removed ${staleSatellites.length} stale satellites`);
            }
        }

        async function update() {
            let telemetry = await fetchTelemetry();
            // normalize to array
            if (!Array.isArray(telemetry)) {
                if (telemetry && typeof telemetry === 'object') {
                    // could be an error envelope or a mapping of sat_id->payload
                    if (telemetry.error) {
                        console.warn('telemetry endpoint returned error', telemetry);
                        telemetry = [];
                    } else {
                        telemetry = Object.values(telemetry);
                    }
                } else {
                    telemetry = [];
                }
            }

            telemetry.forEach(msg => {
                const id = msg.sat_id || msg.id || 'sat';
                const name = msg.name || `SAT-${id}`;
                const pos = msg.position_km || [0, 0, 0];
                
                // Update last seen timestamp for this satellite
                lastSeen[id] = Date.now();
                
                // Convert ECEF coordinates (km) to Cesium Cartesian3 (meters)
                // The satellite positions are already in ECEF coordinates from Earth center
                const x_m = pos[0] * 1000; // convert km to meters
                const y_m = pos[1] * 1000;
                const z_m = pos[2] * 1000;
                const cart = new Cesium.Cartesian3(x_m, y_m, z_m);
                
                // Get orbital info for display
                const orbital = msg.orbital_elements || {};
                const alt = (orbital.alt_km !== undefined) ? `${orbital.alt_km.toFixed(0)}km` : 'Unknown';
                const inc = (orbital.inc_deg !== undefined) ? `${orbital.inc_deg.toFixed(1)}Â°` : 'Unknown';
                const labelText = `${name}\n${alt} @ ${inc}`;
                
                if (!markers[id]) {
                    // Create satellite marker
                    markers[id] = viewer.entities.add({
                        id: id,
                        position: cart,
                        point: { 
                            pixelSize: 12, 
                            color: Cesium.Color.YELLOW,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            heightReference: Cesium.HeightReference.NONE
                        },
                        label: {
                            text: labelText,
                            font: '12pt Helvetica',
                            pixelOffset: new Cesium.Cartesian2(0, -40),
                            fillColor: Cesium.Color.WHITE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE
                        }
                    });

                    // Generate and add orbital path
                    const orbitalPositions = generateOrbitalPath(orbital, name);
                    if (orbitalPositions && orbitalPositions.length > 0) {
                        orbitalPaths[id] = viewer.entities.add({
                            id: `orbit_${id}`,
                            polyline: {
                                positions: orbitalPositions,
                                width: 2,
                                material: Cesium.Color.CYAN.withAlpha(0.6),
                                clampToGround: false
                            }
                        });
                    }
                } else {
                    // Update satellite position and label
                    markers[id].position = cart;
                    markers[id].label.text = labelText;
                    
                    // Update orbital path if orbital elements changed significantly
                    // (for now, we'll just update it periodically to keep it simple)
                }
            });
            
            // Remove satellites that haven't been seen recently
            removeStaleSatellites();
            
            updateSatelliteCount();
            updateMissionTime(telemetry);
        }

        setInterval(update, 1000);
        
        // Initial update
        update();
    </script>
</body>

</html>